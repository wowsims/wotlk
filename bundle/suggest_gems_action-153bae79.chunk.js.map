{"version":3,"file":"suggest_gems_action-153bae79.chunk.js","sources":["../../../ui/core/components/suggest_gems_action.ts"],"sourcesContent":["import { IndividualSimUI } from '../individual_sim_ui.js';\nimport { Player } from '../player.js';\nimport { Sim } from '../sim.js';\nimport { Gear } from '../proto_utils/gear.js';\nimport { EquippedItem } from '../proto_utils/equipped_item.js';\nimport { TypedEvent } from '../typed_event.js';\nimport { Stats } from '../proto_utils/stats.js';\nimport { GemColor, Stat, Profession, ItemSlot, Spec } from '../proto/common.js';\n\ninterface GemCapsData {\n\tgemId: number\n\tstatCaps: Stats\n}\n\ninterface SocketData {\n\titemSlot: ItemSlot\n\tsocketIdx: number\n}\n\ninterface SocketBonusData {\n\titemSlot: ItemSlot | null\n\tsocketBonus: number\n}\n\nabstract class GemOptimizer {\n\tprotected readonly player: Player<Spec>;\n\tprotected readonly sim: Sim;\n\tprotected readonly gemPriorityByColor: Record<GemColor, Array<GemCapsData>>; \n\tabstract metaGemID: number;\t\n\tstatic allGemColors: Array<GemColor> = [GemColor.GemColorRed, GemColor.GemColorYellow, GemColor.GemColorBlue];\n\tepWeights!: Stats;\n\tuseJcGems!: boolean;\n\tisBlacksmithing!: boolean;\n\tnumSocketedJcGems!: number;\n\tjcUpgradePriority: Array<GemCapsData>;\n\n\tstatic jcUpgradesById: Record<number, number> = {\n\t\t40118: 42154,\n\t\t40125: 42156,\n\t\t40112: 42143,\n\t\t40111: 42142,\n\t\t40119: 36767,\n\t};\n\n\tconstructor(simUI: IndividualSimUI<any>) {\n\t\tthis.player = simUI.player;\n\t\tthis.sim = simUI.sim;\n\n\t\t// Initialize empty arrays of gem priorities for each socket color\n\t\tthis.gemPriorityByColor = {} as Record<GemColor, Array<GemCapsData>>;\n\t\t\n\t\tfor (var gemColor of GemOptimizer.allGemColors) {\n\t\t\tthis.gemPriorityByColor[gemColor] = new Array<GemCapsData>();\n\t\t}\n\n\t\tthis.jcUpgradePriority = new Array<GemCapsData>();\t\n\n\t\tsimUI.addAction('Suggest Gems', 'suggest-gems-action', async () => {\n\t\t\tthis.optimizeGems();\n\t\t});\n\t}\n\n\tasync optimizeGems() {\n\t\t// First, clear all existing gems\n\t\tlet optimizedGear = this.player.getGear().withoutGems();\n\t\tthis.numSocketedJcGems = 0;\n\n\t\t// Store relevant player attributes for use in optimizations\n\t\tthis.epWeights = this.player.getEpWeights();\n\t\tthis.useJcGems = this.player.hasProfession(Profession.Jewelcrafting);\n\t\tthis.isBlacksmithing = this.player.isBlacksmithing();\n\n\t\t/*\n\t\t * Use subclass-specific logic to rank order gems of each color by value\n\t\t * and calculate the associated stat caps for each gem (when applicable).\n\t\t */\n\t\tconst ungemmedStats = await this.updateGear(optimizedGear);\n\t\tthis.updateGemPriority(optimizedGear, ungemmedStats);\n\n\t\t// Next, socket and activate the meta\n\t\toptimizedGear = optimizedGear.withMetaGem(this.sim.db.lookupGem(this.metaGemID));\n\t\toptimizedGear = this.activateMetaGem(optimizedGear);\n\t\tawait this.updateGear(optimizedGear);\n\n\t\t// Now loop through all gem colors where a priority list has been defined\n\t\tfor (var gemColor of GemOptimizer.allGemColors) {\n\t\t\tif (this.gemPriorityByColor[gemColor].length > 0) {\n\t\t\t\toptimizedGear = await this.fillGemsByColor(optimizedGear, gemColor);\n\n\t\t\t\t// Also substitute JC gems by priority while respecting stat caps\n\t\t\t\tif (this.useJcGems) {\n\t\t\t\t\toptimizedGear = await this.substituteJcGems(optimizedGear);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\t\n\tasync updateGear(gear: Gear): Promise<Stats> {\n\t\tthis.player.setGear(TypedEvent.nextEventID(), gear);\n\t\tawait this.sim.updateCharacterStats(TypedEvent.nextEventID());\n\t\treturn Stats.fromProto(this.player.getCurrentStats().finalStats);\n\t}\n\n\t/**\n\t * Helper method for meta gem activation.\n\t *\n\t * @remarks\n\t * Based on the ansatz that most specs are forced to use a suboptimal gem color in\n\t * order to statisfy their meta requirements. As a result, it is helpful to\n\t * compute the item slot in a gear set that provides the strongest socket bonus \n\t * for that color, since this should minimize the \"cost\" of activation.\n\t *\n\t * @param gear - Ungemmed gear set\n\t * @param color - Socket color used for meta gem activation\n\t * @param singleOnly - If true, exclude items containing more than one socket of the specified color. If false, instead normalize the socket bonus by the number of such sockets.\n\t * @param blacklistedColor - If non-null, exclude items containing any sockets of this color (assumed to be different from the color used for activation).\n\t * @returns Optimal item slot for activation under the specified constraints, or null if not found.\n\t */\t\n\tfindStrongestSocketBonus(gear: Gear, color: GemColor, singleOnly: boolean, blacklistedColor: GemColor | null): SocketBonusData {\n\t\tlet optimalSlot: ItemSlot | null = null;\n\t\tlet maxSocketBonusEP: number = 1e-8;\n\n\t\tfor (var slot of gear.getItemSlots()) {\n\t\t\tconst item = gear.getEquippedItem(slot);\n\n\t\t\tif (!item) {\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tif (item.numSocketsOfColor(blacklistedColor) != 0) {\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tconst numSockets = item.numSocketsOfColor(color);\n\n\t\t\tif ((numSockets == 0) || (singleOnly && (numSockets != 1))) {\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tconst socketBonusEP = new Stats(item.item.socketBonus).computeEP(this.epWeights);\n\t\t\tconst normalizedEP = socketBonusEP / numSockets;\n\n\t\t\tif (normalizedEP > maxSocketBonusEP) {\n\t\t\t\toptimalSlot = slot;\n\t\t\t\tmaxSocketBonusEP = normalizedEP;\n\t\t\t}\n\t\t}\n\n\t\treturn { itemSlot: optimalSlot, socketBonus: maxSocketBonusEP };\n\t}\n\t\n\tsocketGemInFirstMatchingSocket(gear: Gear, itemSlot: ItemSlot | null, colorToMatch: GemColor, gemId: number): Gear {\n\t\tif (itemSlot != null) {\n\t\t\tconst item = gear.getEquippedItem(itemSlot);\n\n\t\t\tif (!item) {\n\t\t\t\treturn gear;\n\t\t\t}\n\n\t\t\tfor (const [socketIdx, socketColor] of item!.allSocketColors().entries()) {\n\t\t\t\tif (socketColor == colorToMatch) {\n\t\t\t\t\treturn gear.withEquippedItem(itemSlot, item!.withGem(this.sim.db.lookupGem(gemId), socketIdx), true);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\treturn gear;\n\t}\n\n\tasync fillGemsByColor(gear: Gear, color: GemColor): Promise<Gear> {\n\t\tconst socketList = this.findSocketsByColor(gear, color);\n\t\treturn await this.fillGemsToCaps(gear, socketList, this.gemPriorityByColor[color], 0, 0);\n\t}\n\t\n\t/**\n\t * Shared wrapper for compiling eligible sockets for each gem priority list.\n\t *\n\t * @remarks\n\t * Subclasses are required to implement the allowGemInSocket method, which\n\t * contains the (spec-specific) logic on when to match socket bonuses etc.\n\t *\n\t * @param gear - Partially gemmed gear set\n\t * @param color - Color associated with a single gem priority list\n\t * @returns Array of sockets that will be filled using the priority list associated with the specified color.\n\t */\t\n\tfindSocketsByColor(gear: Gear, color: GemColor): Array<SocketData> {\n\t\tconst socketList = new Array<SocketData>();\n\n\t\tfor (var slot of gear.getItemSlots()) {\n\t\t\tconst item = gear.getEquippedItem(slot);\n\n\t\t\tif (!item) {\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tfor (const [socketIdx, socketColor] of item.curSocketColors(this.isBlacksmithing).entries()) {\n\t\t\t\tif (item!.hasSocketedGem(socketIdx)) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\n\t\t\t\tif (this.allowGemInSocket(color, socketColor, slot, item)) {\n\t\t\t\t\tsocketList.push({ itemSlot: slot, socketIdx: socketIdx });\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\treturn socketList;\n\t}\n\n\tasync substituteJcGems(gear: Gear): Promise<Gear> {\n\t\tlet updatedGear: Gear = gear;\n\t\tlet gemIdx = 0;\n\n\t\twhile ((this.numSocketedJcGems < 3) && (gemIdx < this.jcUpgradePriority.length)) {\n\t\t\tconst gemData = this.jcUpgradePriority[gemIdx];\n\t\t\tconst baseGem = this.sim.db.lookupGem(gemData.gemId);\n\n\t\t\tif (!updatedGear.getAllGems(this.isBlacksmithing).includes(baseGem!)) {\n\t\t\t\tgemIdx += 1;\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tconst upgradedGem = this.sim.db.lookupGem(GemOptimizer.jcUpgradesById[gemData.gemId]);\n\t\t\tconst testGear = updatedGear.withSingleGemSubstitution(baseGem, upgradedGem, this.isBlacksmithing);\n\t\t\tconst newStats = await this.updateGear(testGear);\n\n\t\t\tif (newStats.belowCaps(gemData.statCaps)) {\n\t\t\t\tupdatedGear = testGear;\n\t\t\t\tthis.numSocketedJcGems += 1;\n\t\t\t} else {\n\t\t\t\tawait this.updateGear(updatedGear);\n\t\t\t\tgemIdx += 1;\n\t\t\t}\t\n\t\t}\n\n\t\treturn updatedGear;\n\t}\n\t\n\tasync fillGemsToCaps(gear: Gear, socketList: Array<SocketData>, gemCaps: Array<GemCapsData>, numPasses: number, firstIdx: number): Promise<Gear> {\n\t\tlet updatedGear: Gear = gear;\n\t\tconst currentGem = this.sim.db.lookupGem(gemCaps[numPasses].gemId);\n\n\t\t// On the first pass, we simply fill all sockets with the highest priority gem\n\t\tif (numPasses == 0) {\n\t\t\tfor (var socketData of socketList.slice(firstIdx)) {\n\t\t\t\tupdatedGear = updatedGear.withGem(socketData.itemSlot, socketData.socketIdx, currentGem);\n\t\t\t}\n\t\t}\n\n\t\t// If we are below the relevant stat cap for the gem we just filled on the last pass, then we are finished.\n\t\tlet newStats = await this.updateGear(updatedGear);\n\t\tconst currentCap = gemCaps[numPasses].statCaps;\n\n\t\tif (newStats.belowCaps(currentCap) || (numPasses == gemCaps.length - 1)) {\n\t\t\treturn updatedGear;\n\t\t}\n\n\t\t// If we exceeded the stat cap, then work backwards through the socket list and replace each gem with the next highest priority option until we are below the cap\n\t\tconst nextGem = this.sim.db.lookupGem(gemCaps[numPasses + 1].gemId);\n\t\tconst nextCap = gemCaps[numPasses + 1].statCaps;\n\t\tlet capForReplacement = currentCap.subtract(nextCap);\n\n\t\tif (currentCap.computeEP(capForReplacement) <= 0) {\n\t\t\tcapForReplacement = currentCap;\n\t\t}\n\n\t\tfor (var idx = socketList.length - 1; idx >= firstIdx; idx--) {\n\t\t\tif (newStats.belowCaps(capForReplacement)) {\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tupdatedGear = updatedGear.withGem(socketList[idx].itemSlot, socketList[idx].socketIdx, nextGem);\n\t\t\tnewStats = await this.updateGear(updatedGear);\n\t\t}\n\n\t\t// Now run a new pass to check whether we've exceeded the next stat cap\n\t\tlet nextIdx = idx + 1;\n\n\t\tif (!newStats.belowCaps(currentCap)) {\n\t\t\tnextIdx = firstIdx;\n\t\t}\n\n\t\treturn await this.fillGemsToCaps(updatedGear, socketList, gemCaps, numPasses + 1, nextIdx);\n\t}\n\n\tabstract activateMetaGem(gear: Gear): Gear;\n\n\tabstract updateGemPriority(ungemmedGear: Gear, passiveStats: Stats): void;\n\n\tabstract allowGemInSocket(gemColor: GemColor, socketColor: GemColor, itemSlot: ItemSlot, item: EquippedItem): boolean;\n}\n\nexport class PhysicalDPSGemOptimizer extends GemOptimizer {\n\tmetaGemID: number = 41398; // Relentless Earthsiege Diamond\n\tarpSlop: number = 11;\n\texpSlop: number = 4;\n\thitTarget: number = 8. * 32.79;\n\thitSlop: number = 4;\n\tuseArpGems: boolean;\n\tuseExpGems: boolean;\n\tuseAgiGems: boolean;\n\tuseStrGems: boolean;\n\tarpTarget!: number;\n\tpassiveArp!: number;\n\tarpStackDetected!: boolean;\n\tpassiveHit!: number;\n\ttearSlot!: ItemSlot | null;\n\n\tconstructor(simUI: IndividualSimUI<any>, useArpGems: boolean, useExpGems: boolean, useAgiGems: boolean, useStrGems: boolean) {\n\t\tsuper(simUI);\n\t\tthis.useArpGems = useArpGems;\n\t\tthis.useExpGems = useExpGems;\n\t\tthis.useAgiGems = useAgiGems;\n\t\tthis.useStrGems = useStrGems;\n\t}\n\n\tupdateGemPriority(ungemmedGear: Gear, passiveStats: Stats) {\n\t\t// First calculate any gear-dependent stat caps.\n\t\tthis.arpTarget = this.calcArpTarget(ungemmedGear);\n\t\tconst critCap = this.calcCritCap(ungemmedGear);\n\t\tconst expCap = new Stats().withStat(Stat.StatExpertise, this.calcExpTarget() + this.expSlop);\n\t\tthis.passiveHit = passiveStats.getStat(Stat.StatMeleeHit);\n\t\tconst hitCap = new Stats().withStat(Stat.StatMeleeHit, this.hitTarget + this.hitSlop);\n\n\t\t// Reset optimal Tear slot from prior calculations\n\t\tthis.tearSlot = null;\n\t\t\n\t\t/*\n\t\t * For specs that gem ArP, determine whether the current gear\n\t\t * configuration will optimally hard stack Fractured gems or not.\n\t\t */\n\t\tthis.passiveArp = passiveStats.getStat(Stat.StatArmorPenetration);\n\t\tthis.arpStackDetected = this.detectArpStackConfiguration(ungemmedGear);\n\n\t\t/*\n\t\t * Use tighter constraint on overcapping ArP for hard stack setups, so as\n\t\t * to reduce the number of missed yellow socket bonuses.\n\t\t */\n\t\tconst arpSlop = this.arpStackDetected ? 4 : this.arpSlop;\n\t\tconst arpCap = new Stats().withStat(Stat.StatArmorPenetration, this.arpTarget + arpSlop);\n\n\t\t// Update red gem priority\n\t\tconst redGemCaps = new Array<GemCapsData>();\n\n\t\t// Fractured Cardinal Ruby\n\t\tif (this.useArpGems) {\n\t\t\tredGemCaps.push({ gemId: 40117, statCaps: arpCap });\n\t\t}\n\n\t\t// Precise Cardinal Ruby\n\t\tif (this.useExpGems) {\n\t\t\tredGemCaps.push({ gemId: 40118, statCaps: expCap });\n\t\t}\n\n\t\t// Delicate Cardinal Ruby\n\t\tif (this.useAgiGems) {\n\t\t\tredGemCaps.push({ gemId: 40112, statCaps: critCap });\n\t\t}\n\n\t\t// Bold Cardinal Ruby\n\t\tif (this.useStrGems) {\n\t\t\tredGemCaps.push({ gemId: 40111, statCaps: new Stats() });\n\t\t}\n\n\t\tthis.gemPriorityByColor[GemColor.GemColorRed] = redGemCaps;\n\n\t\t// Update yellow gem priority\n\t\tconst yellowGemCaps = new Array<GemCapsData>();\n\n\t\t// Accurate Ametrine\n\t\tif (this.useExpGems) {\n\t\t\tyellowGemCaps.push({ gemId: 40162, statCaps: hitCap.add(expCap) });\n\t\t}\n\n\t\t// Rigid Ametrine\n\t\tyellowGemCaps.push({ gemId: 40125, statCaps: hitCap });\n\n\t\t// Fractured Cardinal Ruby\n\t\tif (this.arpStackDetected) {\n\t\t\tyellowGemCaps.push({ gemId: 40117, statCaps: arpCap });\n\t\t}\n\t\t\n\t\t// Accurate Ametrine (needed to add twice to catch some edge cases)\n\t\tif (this.useExpGems) {\n\t\t\tyellowGemCaps.push({ gemId: 40162, statCaps: hitCap.add(expCap) });\n\t\t}\n\n\t\t// Glinting Ametrine\n\t\tif (this.useAgiGems) {\n\t\t\tyellowGemCaps.push({ gemId: 40148, statCaps: hitCap.add(critCap) });\n\t\t}\n\n\t\t// Etched Ametrine\n\t\tif (this.useStrGems) {\n\t\t\tyellowGemCaps.push({ gemId: 40143, statCaps: hitCap });\n\t\t}\n\n\t\t// Deadly Ametrine\n\t\tif (this.useAgiGems) {\n\t\t\tyellowGemCaps.push({ gemId: 40147, statCaps: critCap });\n\t\t}\n\n\t\t// Inscribed Ametrine\n\t\tif (this.useStrGems) {\n\t\t\tyellowGemCaps.push({ gemId: 40142, statCaps: critCap });\n\t\t}\n\n\t\t// Fierce Ametrine\n\t\tif (this.useStrGems) {\n\t\t\tyellowGemCaps.push({ gemId: 40146, statCaps: new Stats() });\n\t\t}\n\t\t\n\t\tthis.gemPriorityByColor[GemColor.GemColorYellow] = yellowGemCaps;\n\n\t\t// Update JC upgrade priority\n\t\tthis.jcUpgradePriority = new Array<GemCapsData>();\n\t\t\n\t\tif (this.useExpGems) {\n\t\t\tthis.jcUpgradePriority.push({ gemId: 40118, statCaps: expCap });\n\t\t}\n\t\t\n\t\tif (this.useAgiGems) {\n\t\t\tthis.jcUpgradePriority.push({ gemId: 40112, statCaps: critCap });\n\t\t}\n\n\t\tif (this.useStrGems) {\n\t\t\tthis.jcUpgradePriority.push({ gemId: 40111, statCaps: new Stats() });\n\t\t}\n\t}\n\n\tdetectArpStackConfiguration(ungemmedGear: Gear): boolean {\n\t\tif (!this.useArpGems) {\n\t\t\treturn false;\n\t\t}\n\n\t\t/*\n\t\t * Generate a \"dummy\" list of red sockets in order to determine whether\n\t\t * ignoring yellow socket bonuses to stack more ArP gems will be correct.\n\t\t * Subtract 2 from the length of this list to account for meta gem +\n\t\t * Nightmare Tear.\n\t\t */\n\t\tconst dummyRedSocketList = this.findSocketsByColor(ungemmedGear, GemColor.GemColorRed);\n\t\tconst numRedSockets = dummyRedSocketList.length - 2;\n\t\tlet projectedArp = this.passiveArp + 20 * numRedSockets;\n\n\t\tif (this.useJcGems) {\n\t\t\tprojectedArp += 42;\n\t\t}\n\n\t\treturn (this.arpTarget > 1000) && (projectedArp > 648) && (projectedArp + 20 < this.arpTarget + 4);\n\t}\n\n\tactivateMetaGem(gear: Gear): Gear {\n\t\t/*\n\t\t * Use a single Nightmare Tear for meta activation. Prioritize blue\n\t\t * sockets for it if possible, and fall back to yellow sockets if not.\n\t\t */\n\t\tconst blueSlotCandidate = this.findBlueTearSlot(gear);\n\t\tconst yellowSlotCandidate = this.findYellowTearSlot(gear);\n\n\t\tlet tearColor = GemColor.GemColorBlue;\n\t\tthis.tearSlot = blueSlotCandidate.itemSlot;\n\n\t\tif ((this.tearSlot == null) || (this.arpStackDetected && (yellowSlotCandidate.socketBonus > blueSlotCandidate.socketBonus))) {\n\t\t\ttearColor = GemColor.GemColorYellow;\n\t\t\tthis.tearSlot = yellowSlotCandidate.itemSlot;\n\t\t}\n\n\t\treturn this.socketTear(gear, tearColor);\n\t}\n\t\n\tsocketTear(gear: Gear, tearColor: GemColor): Gear {\n\t\treturn this.socketGemInFirstMatchingSocket(gear, this.tearSlot, tearColor, 49110);\n\t}\n\t\n\tfindBlueTearSlot(gear: Gear): SocketBonusData {\n\t\t// Eligible Tear slots have only one blue socket max.\n\t\tconst singleOnly = true;\n\n\t\t/*\n\t\t * Additionally, for hard ArP stack configurations, only use blue sockets\n\t\t * for Tear if there are no yellow sockets in that item slot, since hard\n\t\t * ArP stacks ignore yellow socket bonuses in favor of stacking more\n\t\t * Fractured gems.\n\t\t */\n\t\tconst blacklistedColor = this.arpStackDetected ? GemColor.GemColorYellow : null;\n\n\t\treturn this.findStrongestSocketBonus(gear, GemColor.GemColorBlue, singleOnly, blacklistedColor);\n\t}\n\n\tfindYellowTearSlot(gear: Gear): SocketBonusData {\n\t\treturn this.findStrongestSocketBonus(gear, GemColor.GemColorYellow, false, GemColor.GemColorBlue);\n\t}\n\t\n\tallowGemInSocket(gemColor: GemColor, socketColor: GemColor, itemSlot: ItemSlot, item: EquippedItem): boolean {\n\t\tconst ignoreYellowSockets = ((item!.numSocketsOfColor(GemColor.GemColorBlue) > 0) && (itemSlot != this.tearSlot));\n\t\tlet matchYellowSocket = false;\n\t\t\n\t\tif ((socketColor == GemColor.GemColorYellow) && !ignoreYellowSockets) {\n\t\t\tmatchYellowSocket = new Stats(item.item.socketBonus).computeEP(this.epWeights) > 1e-8;\n\t\t}\n\n\t\treturn ((gemColor == GemColor.GemColorYellow) && matchYellowSocket) || ((gemColor == GemColor.GemColorRed) && !matchYellowSocket);\n\t}\n\t\n\tfindSocketsByColor(gear: Gear, color: GemColor): Array<SocketData> {\n\t\tconst socketList = super.findSocketsByColor(gear, color);\n\n\t\tif (this.arpStackDetected && (color == GemColor.GemColorYellow)) {\n\t\t\tthis.sortYellowSockets(gear, socketList);\n\t\t}\n\n\t\treturn socketList;\n\t}\n\t\n\tsortYellowSockets(gear: Gear, yellowSocketList: Array<SocketData>) {\n\t\tyellowSocketList.sort((a,b) => {\n\t\t\t// If both yellow sockets belong to the same item, then treat them equally.\n\t\t\tconst slot1 = a.itemSlot;\n\t\t\tconst slot2 = b.itemSlot;\n\n\t\t\tif (slot1 == slot2) {\n\t\t\t\treturn 0;\n\t\t\t}\n\n\t\t\t// If an item already has a Nightmare Tear socketed, then bump up any yellow sockets in it to highest priority.\n\t\t\tif (slot1 == this.tearSlot) {\n\t\t\t\treturn -1;\n\t\t\t}\n\n\t\t\tif (slot2 == this.tearSlot) {\n\t\t\t\treturn 1;\n\t\t\t}\n\n\t\t\t// For all other cases, sort by the ratio of the socket bonus value divided by the number of yellow sockets required to activate it.\n\t\t\tconst item1 = gear.getEquippedItem(slot1);\n\t\t\tconst bonus1 = new Stats(item1!.item.socketBonus).computeEP(this.epWeights);\n\t\t\tconst item2 = gear.getEquippedItem(slot2);\n\t\t\tconst bonus2 = new Stats(item2!.item.socketBonus).computeEP(this.epWeights);\n\t\t\treturn bonus2 / item2!.numSocketsOfColor(GemColor.GemColorYellow) - bonus1 / item1!.numSocketsOfColor(GemColor.GemColorYellow);\n\t\t});\n\t}\n\t\n\tcalcArpTarget(gear: Gear): number {\n\t\tlet arpTarget = 1399;\n\n\t\t/*\n\t\t * First handle ArP proc trinkets. If more than one of these are equipped\n\t\t * simultaneously, it is assumed that the user is desyncing them via ICD\n\t\t * resets, such that the soft cap is set by the strongest proc.\n\t\t */\n\t\tif (gear.hasTrinket(45931)) {\n\t\t\tarpTarget -= 751; // Mjolnir Runestone\n\t\t} else if (gear.hasTrinket(50198)) {\n\t\t\tarpTarget -= 678; // Needle-Encrusted Scorpion\n\t\t} else if (gear.hasTrinket(40256)) {\n\t\t\tarpTarget -= 612; // Grim Toll\n\t\t}\n\n\t\t// Then check for Executioner enchant\n\t\tconst weapon = gear.getEquippedItem(ItemSlot.ItemSlotMainHand);\n\n\t\tif (weapon?.enchant?.effectId == 3225) {\n\t\t\tarpTarget -= 120;\n\t\t}\n\n\t\treturn arpTarget;\n\t}\n\n\tcalcExpTarget(): number {\n\t\treturn 6.5 * 32.79;\n\t}\n\t\n\tcalcCritCap(gear: Gear): Stats {\n\t\t/*\n\t\t * Only some specs incorporate Crit soft caps into their gemming logic, so\n\t\t * the parent method here simply returns an empty Stats object (meaning\n\t\t * that Crit cap will just be ignored elsewhere in the code). Custom\n\t\t * spec-specific subclasses can override this as desired.\n\t\t */\n\t\treturn new Stats();\n\t}\n\t\n\tasync fillGemsByColor(gear: Gear, color: GemColor): Promise<Gear> {\n\t\t/*\n\t\t * Parent logic substitutes JC gems after filling normal gems first, but\n\t\t * for specs that gem ArP, it is more optimal to pre-fill some Fractured\n\t\t * Dragon's Eyes if doing so gets us closer to the target.\n\t\t */\n\t\tlet updatedGear: Gear = gear;\n\n\t\tif ((color == GemColor.GemColorRed) && this.useArpGems && this.useJcGems) {\n\t\t\tupdatedGear = this.optimizeJcArpGems(updatedGear);\n\t\t}\n\n\t\t// Likewise, if we still have JC gems available after finishing the red gems, then force utilization of JC Hit gems if possible.\n\t\tif ((color == GemColor.GemColorYellow) && this.useJcGems && (this.numSocketedJcGems < 3)) {\n\t\t\tupdatedGear = this.fillJcHitGems(updatedGear);\n\t\t}\n\n\t\treturn await super.fillGemsByColor(updatedGear, color);\n\t}\n\n\tcalcDistanceToArpTarget(numJcArpGems: number, numRedSockets: number): number {\n\t\tconst numNormalArpGems = Math.max(0, Math.min(numRedSockets - 3, Math.floor((this.arpTarget + this.arpSlop - this.passiveArp - 34 * numJcArpGems) / 20)));\n\t\tconst projectedArp = this.passiveArp + 34 * numJcArpGems + 20 * numNormalArpGems;\n\t\treturn Math.abs(projectedArp - this.arpTarget);\n\t}\n\n\toptimizeJcArpGems(gear: Gear): Gear {\n\t\t// First determine how many of the JC gems should be 34 ArP gems\n\t\tconst redSocketList = this.findSocketsByColor(gear, GemColor.GemColorRed);\n\t\tconst numRedSockets = redSocketList.length;\n\t\tlet optimalJcArpGems = [0,1,2,3].reduce((m,x)=> this.calcDistanceToArpTarget(m, numRedSockets)<this.calcDistanceToArpTarget(x, numRedSockets) ? m:x);\n\t\toptimalJcArpGems = Math.min(optimalJcArpGems, numRedSockets);\n\n\t\t// Now socket just those gems, saving other JC substitutions for later\n\t\tlet updatedGear: Gear = gear;\n\n\t\tfor (let i = 0; i < optimalJcArpGems; i++) {\n\t\t\tupdatedGear = updatedGear.withGem(redSocketList[i].itemSlot, redSocketList[i].socketIdx, this.sim.db.lookupGem(42153));\n\t\t}\n\n\t\tthis.numSocketedJcGems = optimalJcArpGems;\n\t\treturn updatedGear;\n\t}\n\n\tfillJcHitGems(gear: Gear): Gear {\n\t\tconst yellowSocketList = this.findSocketsByColor(gear, GemColor.GemColorYellow);\n\t\tconst maxJcHitGems = Math.min(3 - this.numSocketedJcGems, yellowSocketList.length);\n\t\tconst desiredJcHitGems = Math.max(0, Math.floor((this.hitTarget + this.hitSlop - this.passiveHit) / 34));\n\t\tconst numJcHitGems = Math.min(desiredJcHitGems, maxJcHitGems);\n\n\t\tlet updatedGear: Gear = gear;\n\n\t\tfor (let i = 0; i < numJcHitGems; i++) {\n\t\t\tupdatedGear = updatedGear.withGem(yellowSocketList[i].itemSlot, yellowSocketList[i].socketIdx, this.sim.db.lookupGem(42156));\n\t\t}\n\n\t\tthis.numSocketedJcGems += numJcHitGems;\n\t\treturn updatedGear;\n\t}\n}\n\nexport class TankGemOptimizer extends GemOptimizer {\n\tmetaGemID: number = 41380; // Austere Earthsiege Diamond\n\t\n\tupdateGemPriority(ungemmedGear: Gear, passiveStats: Stats) {\n\t\t// Base class just stuffs pure Stamina gems everywhere\n\t\tconst blueGemCaps = new Array<GemCapsData>();\n\t\tblueGemCaps.push({ gemId: 40119, statCaps: new Stats() });\n\t\tthis.gemPriorityByColor[GemColor.GemColorBlue] = blueGemCaps;\n\t\tthis.jcUpgradePriority = blueGemCaps;\n\t}\n\t\n\tactivateMetaGem(gear: Gear): Gear {\n\t\t/*\n\t\t * Use a single Shifting Dreadstone gem for meta activation, in the slot\n\t\t * with the strongest bonus for a single red socket.\n\t\t */\n\t\treturn this.socketGemInFirstMatchingSocket(gear, this.findStrongestSocketBonus(gear, GemColor.GemColorRed, true, GemColor.GemColorYellow).itemSlot, GemColor.GemColorRed, 40130);\n\t}\n\t\n\tallowGemInSocket(gemColor: GemColor, socketColor: GemColor, itemSlot: ItemSlot, item: EquippedItem): boolean {\n\t\treturn gemColor == GemColor.GemColorBlue;\n\t}\n}\n"],"names":["_GemOptimizer","constructor","simUI","gemColor","__publicField","this","player","sim","gemPriorityByColor","allGemColors","Array","jcUpgradePriority","addAction","async","optimizeGems","optimizedGear","getGear","withoutGems","numSocketedJcGems","epWeights","getEpWeights","useJcGems","hasProfession","Profession","Jewelcrafting","isBlacksmithing","ungemmedStats","updateGear","updateGemPriority","withMetaGem","db","lookupGem","metaGemID","activateMetaGem","length","fillGemsByColor","substituteJcGems","gear","setGear","TypedEvent","nextEventID","updateCharacterStats","Stats","fromProto","getCurrentStats","finalStats","findStrongestSocketBonus","color","singleOnly","blacklistedColor","optimalSlot","maxSocketBonusEP","slot","getItemSlots","item","getEquippedItem","numSocketsOfColor","numSockets","normalizedEP","socketBonus","computeEP","itemSlot","socketGemInFirstMatchingSocket","colorToMatch","gemId","socketIdx","socketColor","allSocketColors","entries","withEquippedItem","withGem","socketList","findSocketsByColor","fillGemsToCaps","curSocketColors","hasSocketedGem","allowGemInSocket","push","updatedGear","gemIdx","gemData","baseGem","getAllGems","includes","upgradedGem","jcUpgradesById","testGear","withSingleGemSubstitution","belowCaps","statCaps","gemCaps","numPasses","firstIdx","currentGem","socketData","slice","newStats","currentCap","nextGem","nextCap","capForReplacement","subtract","idx","nextIdx","GemOptimizer","GemColor","GemColorRed","GemColorYellow","GemColorBlue","PhysicalDPSGemOptimizer","useArpGems","useExpGems","useAgiGems","useStrGems","super","ungemmedGear","passiveStats","arpTarget","calcArpTarget","critCap","calcCritCap","expCap","withStat","Stat","StatExpertise","calcExpTarget","expSlop","passiveHit","getStat","StatMeleeHit","hitCap","hitTarget","hitSlop","tearSlot","passiveArp","StatArmorPenetration","arpStackDetected","detectArpStackConfiguration","arpSlop","arpCap","redGemCaps","yellowGemCaps","add","numRedSockets","projectedArp","blueSlotCandidate","findBlueTearSlot","yellowSlotCandidate","findYellowTearSlot","tearColor","socketTear","ignoreYellowSockets","matchYellowSocket","sortYellowSockets","yellowSocketList","sort","a","b","slot1","slot2","item1","bonus1","item2","hasTrinket","weapon","ItemSlot","ItemSlotMainHand","enchant","effectId","optimizeJcArpGems","fillJcHitGems","calcDistanceToArpTarget","numJcArpGems","numNormalArpGems","Math","max","min","floor","abs","redSocketList","optimalJcArpGems","reduce","m","x","i","maxJcHitGems","desiredJcHitGems","numJcHitGems","TankGemOptimizer","arguments","blueGemCaps"],"mappings":"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"}